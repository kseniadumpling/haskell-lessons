Введение в Haskell
==================

В этом тексте примеры, которые можно непосредственно выполнять в ghci,
будут отмечены символами "ghci> " в начале строки. При проверке примеров
эти символы набирать не нужно. В большинстве случаев после примера
выражения идёт результат его вычисления.

Примеры, которые должны быть включены в файл с исходным текстом программы,
обозначены символами "> ". Эти символы также не нужно набирать при
проверке примеров.

1. Типы данных

В Haskell представлены стандартные типы данных: целые и вещественные числа,
логические величины, символы и строки, а также более сложные типы: списки и
кортежи. Можно также определять произвольные пользовательские типы данных.

Целочисленный тип Int представляет 32-разрядные целые числа со знаком,
с помощью этого типа данных можно представлять числа в диапазоне
[-2147483647, 2147483648].

Используя тип Integer, можно представлять целые числа неограниченной
разрядности:

ghci> 2 ^ 100
1267650600228229401496703205376

Над целыми числами определены, в частности, операции == (равенство),
/= (неравенство), <, >, <=, >=, +, -, *, div (целочисленное деление),
mod (остаток от деления), ^ (возведение в степень), abs (модуль числа).

ghci> 2 + 3
5

ghci> div 10 3
3

ghci> mod 10 3
1

ghci> abs (-100)
100

Обратите внимание на скобки вокруг числа -100 в последнем случае: они нужны
для того, чтобы выражение не было истолковано как "из abs вычесть 100".

Вещественные числа представлены типами данных Float и Double и записываются
так же, как в языке C (например: 3.1415926).
Над вещественными числами определены, в частности, операции ==, /=, <, >, <=,
>=, +, -, *, /, abs, log (натуральный логарифм), ^ (показатель степени должен
быть целым числом), sqrt (извлечение квадратного корня).

Символы записываются в одиночных кавычках: 'c', '!'. Строки записываются в
двойных кавычках: "Hello, Haskell", "Привет!". Для удобства строки
рассматривают как отдельный тип данных, но на самом деле они являются
списками символов. Соответственно, для них определены все операции, которые
определены для списков.

Логический тип данных Bool представлен двумя константами: True (истинное
значение) и False (ложное значение). Над значениями этого типа можно выполнять
операции ==, /=, <, >, <=, >=, && (логическое "и"), || (логическое "или"),
not (отрицание).

В отличие от C и Паскаля, списки в Haskell представлены непосредственно и не
требуют использования адресной арифметики и указателей. Пустой список
записывается как [], непустой список задаётся перечислением элементов через
запятую и заключается в квадратные скобки:

ghci> []
[]

ghci> [1, 2, 3]
[1,2,3]

Для добавления элемента в начало списка используется оператор ":" (двоеточие):

ghci> 0 : [1, 2, 3]
[0,1,2,3]

Первым аргументом оператора (:) должно быть значение, а вторым - список значений
того же типа. В Haskell все элементы одного списка должны иметь один и тот же
тип.

На самом деле запись [1, 2, 3] - синтаксическое украшение, предназначенное для
удобства чтения и записи. В "канонической" форме список [1, 2, 3] записывается
так:

ghci> 1 : 2 : 3 : []
[1,2,3]

Обратите внимание, что добавление нового элемента не меняет список. При
добавлении элемента создаётся новый список, содержащий все элементы
исходного списка и один новый элемент.

Соединить два списка вместе, добавив один в конец другого, можно оператором
"++":

ghci> [1, 2] ++ [3, 4, 5]
[1,2,3,4,5]

Обратиться к элементу с индексом n (начиная с нуля), можно с помощью оператора
"!!":

ghci> [1,2,3,4] !! 2
3

При этом следует помнить, что список не является структурой данных с
произвольным доступом, поэтому использование оператора !! неэффективно.
Если необходим произвольный доступ к элементам, лучше воспользоваться массивами
(модуль Data.Array).

Длина списка вычисляется c помощью функции length:

ghci> length [1, 2, 3]
3

Проверить, пуст ли список, можно с помощью функции null:
ghci> null []
True

ghci> null [1, 2]
False

Кортеж - это упорядоченный набор элементов, имеющий фиксированную длину.
Кортежи записываются в виде заключённого в круглые скобки перечисления
элементов через запятую:

ghci> (1, True)
(1,True)

ghci> ("this", "is", "a", "tuple")
("this","is","a","tuple")


Тип кортежа - это декартово произведение типов элементов кортежа.

2. Определения и выражения

Программа на Haskell строится из модулей, каждый из которых содержит набор
определений. С помощью определений задаются константы, функции и типы данных.
Определение имеет вид

<имя> = <выражение>

Например:

> four = 2 + 2
> eight = four * 2
> numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

В отличие от C и Паскаля, в Haskell нет объявления переменных, то есть ячеек
памяти, значение которых может меняться в процессе выполнения программы. В
программах на Haskell переменная представляет собой имя размещённого в памяти
объекта, причём один и тот же объект может иметь несколько имён. В Haskell нет
операций, которые могли бы изменить значение переменной, но всегда можно
обозначить тем же самым именем изменённый объект.

Поскольку функции в Haskell являются объектами первого класса, то есть могут
использоваться всюду, где можно использовать значения других типов (например,
числа), то константы сами могут быть функциями. Например, можно дать новое имя
функции length, вычисляющей длину списка:

> length' = length

Символ одиночной кавычки может быть частью имени (за исключением первого
символа, чтобы не возникало путаницы с обозначением одиночных символов типа
Char).

Определение функции имеет вид

<имя функции> <имя аргумента> [<имя аргумента> ...] = <выражение>

Функция, которая возвращает удвоенное значение своего аргумента, может быть
определена так:

> double x = x * 2

Функцию можно определить не одним уравнением, а набором уравнений:

> fib 1 = 1
> fib 2 = 1
> fib n = fib (n - 1) + fib (n - 2)

Любое значение в Haskell имеет тип. В большинстве случаев он определяется
автоматически, но можно указать его явно (конструкцию "::" можно читать как
"имеет тип"):

> five :: Int
> five = 5

> square :: Int -> Int
> square x = x * x

Тип "Int -> Int" обозначает функцию, которая действует из множества целых
чисел Int в то же самое множество Int.

Тип функции от нескольких аргументов записывается чуть сложнее:

> max :: Int -> Int -> Int
> max x y = if x > y then x else y

Выражение "Int -> Int -> Int" обозначает, что функция принимает два значения
типа Int и возвращает также значение типа Int. Аналогично, функция, которая
имеет тип String -> Int -> Bool, принимает в качестве первого аргумента
строку, в качестве второго аргумента - целое число, и возвращает логическую
величину (True или False).

Такой необычный способ записи типов функций от нескольких аргументов связан с
особенностью языка Haskell: все функции Haskell можно рассматривать как
функции одного аргумента, которые, в частности, могут возвращать в качестве
значений другие функции. Например, упомянутую функцию

max :: Int -> Int -> Int

можно рассматривать как функцию, которая принимает в качестве аргумента одно
число x и возвращает новую функцию, которая также принимает один аргумент, y,
и возвращает максимум из x и y. При этом значение x "запоминается" в новой
функции (структура данных, содержащая функцию и набор связанных переменных,
называется замыканием). Тип функции max можно было бы записать так:

max :: Int -> (Int -> Int)

С точки зрения Haskell, типы Int -> (Int -> Int) и Int -> Int -> Int полностью эквивалентны.

Возможность рассматривать функции нескольких аргументов как функции одного
аргумента, которые возвращают другую функцию, часто оказывается очень
полезной. Например, рассмотрим простую функцию plus:

> plus :: Int -> Int -> Int
> plus x y = x + y

С её помощью легко можно построить функцию, которая увеличивает свой аргумент
на 1:

> plus1 :: Int -> Int
> plus1 = plus 1

ghci> plus1 6
7

При всей своей простоте такие функции, как увеличение на константу,
оказываются настолько удобны, что в Haskell предусмотрена специальная нотация
для их определения. Рассмотрим, например, операцию сложения. В инфиксной форме
она записывается так:

ghci> 2 + 4
6

Однако её можно записать как обычный вызов функции, заключив её в скобки
(таким образом в Haskell можно записать в префиксной форме любой инфиксный
оператор):

ghci> (+) 2 4
6

Более того, вместе со знаком "+" в скобки можно поместить один из аргументов:

ghci> (2 +) 4
6

ghci> (+ 4) 2
6

Таким образом, функцию plus1 можно было записать как

ghci> plus1 = (+ 1)

Операция сложения коммутативна, поэтому между (1 +) и (+ 1) нет никакой
разницы. Однако для некоммутативных операций это не так:

ghci> (10 /) 5
2.0

ghci> (/ 10) 5
0.5

Ещё одно удобное сокращение определено для списков. Список элементов, которые
строятся по определённому правилу, можно записать в форме, похожей на
математическую запись множества элементов, удовлетворяющих условию. Например,
список всех натуральных чисел от 1 до 100 можно записать в виде

ghci> [1..100]

Верхнюю границу списка можно опускать:

ghci> [1..]

Результатом вычисления такого выражения будет список, содержащий все целые
числа, начиная с единицы. Подобные структуры данных, содержащие бесконечное
количество элементов, очень полезны в программировании на Haskell, поскольку
при вычислении таких выражений реально вычисляются только те элементы, которые
нужны в дальнейших вычислениях.

(Вопрос: почему в таком случае печать значения [1..] не завершается? Чтобы прервать
вывод чисел на экран, нажмите Ctrl-C.)

Убедиться в том, что не все значения бесконечных списков вычисляются, можно на
примере функции take :: Int -> [a] -> [a]. Она принимает в качестве аргумента
целое число n и список list, и возвращает список, содержащий первые n
элементов списка list (или весь список list, если он содержит меньше n
элементов):

ghci> take 3 [1, 2, 3, 4, 5]
[1,2,3]

ghci> take 10 [1..]
[1,2,3,4,5,6,7,8,9,10]

Так как для работы функции take с аргументом 10 требуется не более 10
элементов списка, только первые 10 элементов списка [1..] будут вычислены.
Таким образом, "бесконечные" структуры данных (в частности, списки) на самом
деле представляют собой порождающии функции, которые вычисляют очередной
элемент, когда он потребуется вызывающей функции.

Дополнением к фунции take является функция drop :: Int -> [a] -> [a], которая
отбрасывает первые n элементов списка и возвращает оставшиеся элементы
(возможно, бесконечный список).

С помощью функций take и drop легко написать, например, функцию
sublist n k list, которая будет возвращать n элементов списка list, начиная
с k-го.

> sublist :: Int -> Int -> [a] -> [a]
> sublist n k list = take n (drop k list)

Эта функция строится как композиция функций take и drop. Её можно записать
по-другому: 

> sublist' :: Int -> Int -> [a] -> [a]
> sublist' n k = take n . drop k

Оператор (.) является оператором композиции функций одной переменной.
Он определен следующим образом:

  (.) :: (b -> c) -> (a -> b) -> a -> c
  (f . g) x = f (g x)

Каждая из функций take и drop принимает два аргумента, число элементов
и список. Как было указано выше, их можно рассматривать как функции, которые
получают один аргумент - число элементов - и возвращают функцию, которая будет
выбирать (или отбрасывать) это число элементов переданного им в качестве
аргумента списка.

ghci> :t take 5
take 5 :: [a] -> [a]

ghci> :t drop 5
drop 5 :: [a] -> [a]

Так как каждая из получившихся функций является функцией одной переменной,
можно построить их композицию:

  take 5 (drop 5 x) == (take 5 . drop 5) x

Списки можно также задавать, указывая условия, которым должны удовлетворять
элементы. Например, список всех четных неотрицательных целых чисел можно
определить так:

ghci> [ x | x <- [1..10], x `mod` 2 = 0 ]
[2,4,6,8,10]
